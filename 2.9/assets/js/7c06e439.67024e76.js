"use strict";(self.webpackChunknoodl_docs=self.webpackChunknoodl_docs||[]).push([[9701],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),s=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),d=s(n),u=r,h=d["".concat(l,".").concat(u)]||d[u]||m[u]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p[d]="string"==typeof e?e:r,i[1]=p;for(var s=2;s<o;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},90646:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>p,toc:()=>s});var a=n(87462),r=(n(67294),n(3905));const o={hide_title:!0,hide_table_of_contents:!0,title:"Parent Component Object node"},i=void 0,p={unversionedId:"component-utilities/parent-component-object/README",id:"component-utilities/parent-component-object/README",title:"Parent Component Object node",description:"Parent Component Object is always used in combination with a Component Object. A Parent Component Object will search upwards in the component tree until it finds a Component Object node and mirror that node. Any change being done to one node will be reflected in the other nodes. Multiple Parent Component Object nodes in the same component will always mirror the same Component Object.",source:"@site/nodes/component-utilities/parent-component-object/README.md",sourceDirName:"component-utilities/parent-component-object",slug:"/component-utilities/parent-component-object/",permalink:"/2.9/nodes/component-utilities/parent-component-object/",draft:!1,tags:[],version:"current",frontMatter:{hide_title:!0,hide_table_of_contents:!0,title:"Parent Component Object node"},sidebar:"nodeSidebar",previous:{title:"Component Object node",permalink:"/2.9/nodes/component-utilities/component-object/"},next:{title:"Set Component Object Properties node",permalink:"/2.9/nodes/component-utilities/set-component-object-properties/"}},l={},s=[{value:"Inputs",id:"inputs",level:2},{value:"Properties",id:"properties",level:3},{value:"Outputs",id:"outputs",level:2},{value:"Properties",id:"properties-1",level:3}],c={toc:s},d="wrapper";function m(e){let{components:t,...o}=e;return(0,r.kt)(d,(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",{className:"is-hidden"},""),(0,r.kt)("h1",{id:"parent-component-object"},"Parent Component Object"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parent Component Object")," is always used in combination with a ",(0,r.kt)("a",{parentName:"p",href:"/nodes/component-utilities/component-object"},"Component Object"),". A ",(0,r.kt)("strong",{parentName:"p"},"Parent Component Object")," will search upwards in the component tree until it finds a ",(0,r.kt)("strong",{parentName:"p"},"Component Object")," node and mirror that node. Any change being done to one node will be reflected in the other nodes. Multiple ",(0,r.kt)("strong",{parentName:"p"},"Parent Component Object")," nodes in the same component will always mirror the same ",(0,r.kt)("strong",{parentName:"p"},"Component Object"),"."),(0,r.kt)("div",{className:"ndl-image-with-background"},(0,r.kt)("p",null,(0,r.kt)("img",{src:n(47269).Z,width:"702",height:"374"}))),(0,r.kt)("p",null,"The node is used much like an ",(0,r.kt)("a",{parentName:"p",href:"/nodes/data/object/object-node"},"Object")," where you can output properties on the node. The node does not have an ",(0,r.kt)("strong",{parentName:"p"},"Id")," instead the data is shared with the parent component. This node is very useful in patterns such as radio groups where child components may need to access the ",(0,r.kt)("strong",{parentName:"p"},"Component Object")," of its parent.\n"),(0,r.kt)("h2",{id:"inputs"},"Inputs"),(0,r.kt)("h3",{id:"properties"},"Properties"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Data"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("span",{className:"ndl-data"},"Properties")),(0,r.kt)("td",{parentName:"tr",align:null},"<##input:value-","*","##>The properties to set on the closest parent ",(0,r.kt)("a",{parentName:"td",href:"/nodes/component-utilities/component-object"},"Component Object"),". When this input is changed via a connection the parent ",(0,r.kt)("strong",{parentName:"td"},"Component Object")," will be updated.")))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Signal"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("span",{className:"ndl-signal"},"Fetch")),(0,r.kt)("td",{parentName:"tr",align:null},"Normally when a ",(0,r.kt)("strong",{parentName:"td"},"Parent Component State")," is created, the property outputs are immediately updated. If you want to control how the data is updated you can connect to the ",(0,r.kt)("em",{parentName:"td"},"Fetch")," signal input. Then you need to explictly send a signal to fetch the data.",(0,r.kt)("br",null),(0,r.kt)("br",null),"With ",(0,r.kt)("strong",{parentName:"td"},"Fetch")," connected the output data won't change until ",(0,r.kt)("strong",{parentName:"td"},"Fetch")," is explicitly triggered again.")))),(0,r.kt)("h2",{id:"outputs"},"Outputs"),(0,r.kt)("h3",{id:"properties-1"},"Properties"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Data"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("span",{className:"ndl-data"},"Parent Properties")),(0,r.kt)("td",{parentName:"tr",align:null},"<##output:value-","*","##>The values of the properties of the closest parent ",(0,r.kt)("a",{parentName:"td",href:"/nodes/component-utilities/component-object"},"Component Object"),".")))),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Signal"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("span",{className:"ndl-signal"},"Changed")),(0,r.kt)("td",{parentName:"tr",align:null},"This event is triggered when any of the properties have changed.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("span",{className:"ndl-signal"},"Fetched")),(0,r.kt)("td",{parentName:"tr",align:null},"Signal when this node has bound itself to a ",(0,r.kt)("a",{parentName:"td",href:"/nodes/component-utilities/component-object"},"Component Object"),". Triggers immediately if the ",(0,r.kt)("strong",{parentName:"td"},"Fetch")," inputs isn't connected, and will otherwise trigger when the ",(0,r.kt)("strong",{parentName:"td"},"Fetch")," input is signaled.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("span",{className:"ndl-signal"},"Changed Property Signals")),(0,r.kt)("td",{parentName:"tr",align:null},"<##output:changed-","*","##>One changed signal output will be created for every property. They will emit a signal when the property changes value.")))))}m.isMDXComponent=!0},47269:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/parent-component-object-6155ae11c9d50c1dd58ce1b2574cbf61.png"}}]);