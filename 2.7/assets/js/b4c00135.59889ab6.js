"use strict";(self.webpackChunknew_noodl_docs=self.webpackChunknew_noodl_docs||[]).push([[6466],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var o=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=o.createContext({}),c=function(e){var n=o.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return o.createElement(p.Provider,{value:n},e.children)},l={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,p=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(t),m=r,g=d["".concat(p,".").concat(m)]||d[m]||l[m]||a;return t?o.createElement(g,i(i({ref:n},u),{},{components:t})):o.createElement(g,i({ref:n},u))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,i=new Array(a);i[0]=d;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<a;c++)i[c]=t[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},44820:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return p},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return l}});var o=t(83117),r=t(80102),a=(t(67294),t(3905)),i=["components"],s={title:"Directions API with the Mapbox Module",hide_title:!0},p=void 0,c={unversionedId:"modules/mapbox/guides/directions-api/README",id:"modules/mapbox/guides/directions-api/README",title:"Directions API with the Mapbox Module",description:"Here are some code heavy example of how to use the Directions API in Noodl.",source:"@site/library/modules/mapbox/guides/directions-api/README.md",sourceDirName:"modules/mapbox/guides/directions-api",slug:"/modules/mapbox/guides/directions-api/",permalink:"/2.7/library/modules/mapbox/guides/directions-api/",tags:[],version:"current",frontMatter:{title:"Directions API with the Mapbox Module",hide_title:!0},sidebar:"mapboxSidebar",previous:{title:"Setting up the Mapbox Module",permalink:"/2.7/library/modules/mapbox/guides/setting-up/"},next:{title:"Interacting with the Mapbox Module",permalink:"/2.7/library/modules/mapbox/guides/interacting/"}},u={},l=[{value:"Listen to on click events on Mapbox",id:"listen-to-on-click-events-on-mapbox",level:2},{value:"Create a route path on Mapbox",id:"create-a-route-path-on-mapbox",level:2}],d={toc:l};function m(e){var n=e.components,t=(0,r.Z)(e,i);return(0,a.kt)("wrapper",(0,o.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"directions-api-with-the-mapbox-module"},"Directions API with the Mapbox Module"),(0,a.kt)("p",null,"Here are some code heavy example of how to use the Directions API in Noodl.\nThe code in this example is using ",(0,a.kt)("a",{parentName:"p",href:"https://docs.mapbox.com/help/tutorials/getting-started-directions-api/"},"Getting started with the Mapbox Directions API\n")," guide."),(0,a.kt)("h2",{id:"listen-to-on-click-events-on-mapbox"},"Listen to on click events on Mapbox"),(0,a.kt)("p",null,"Script node:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'Script.Outputs = {\n  ["Mapbox Object"]: "*",\n  ["Clicked"]: "signal",\n  ["Clicked Longitude"]: "number",\n  ["Clicked Latitute"]: "number"\n};\n\nScript.Signals["Mount Click Event"] = function () {\n  // Listen to the Mapbox on click event\n  // NOTE: This might cause some memory leaks,\n  //       Not sure how Mapbox is handling it.\n  Script.Inputs["Mapbox Object"].on("click", (event) => {\n    // Get the coordinates that the user pressed on\n    const coords = Object.keys(event.lngLat).map((key) => event.lngLat[key]);\n    \n    // Set the Noodl outputs\n    Script.Outputs["Clicked Longitude"] = coords[0];\n    Script.Outputs["Clicked Latitute"] = coords[1];\n\n    // Send the click signal\n    Script.Outputs["Clicked"]();\n  });\n};\n')),(0,a.kt)("h2",{id:"create-a-route-path-on-mapbox"},"Create a route path on Mapbox"),(0,a.kt)("p",null,"Script node:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// This function makes a Mapbox Directions API request\nasync function getRoute(map, start, end) {\n  const accessToken = Noodl.getProjectSettings().mapboxAccessToken;\n\n  // make a directions request using cycling profile\n  // an arbitrary start will always be the same\n  // only the end or destination will change\n  const query = await fetch(\n    `https://api.mapbox.com/directions/v5/mapbox/cycling/${start[0]},${start[1]};${end[0]},${end[1]}?steps=true&geometries=geojson&access_token=${accessToken}`,\n    { method: "GET" }\n  );\n  const json = await query.json();\n  const data = json.routes[0];\n  const route = data.geometry.coordinates;\n  const geojson = {\n    type: "Feature",\n    properties: {},\n    geometry: {\n      type: "LineString",\n      coordinates: route,\n    },\n  };\n  // if the route already exists on the map, we\'ll reset it using setData\n  if (map.getSource("route")) {\n    map.getSource("route").setData(geojson);\n  }\n  // otherwise, we\'ll make a new request\n  else {\n    map.addLayer({\n      id: "route",\n      type: "line",\n      source: {\n        type: "geojson",\n        data: geojson,\n      },\n      layout: {\n        "line-join": "round",\n        "line-cap": "round",\n      },\n      paint: {\n        "line-color": "#3887be",\n        "line-width": 5,\n        "line-opacity": 0.75,\n      },\n    });\n  }\n\n  return data;\n}\n\n//\n// Start of Noodl Script\n//\n\nScript.Inputs = {\n  map: {\n    displayName: "Mapbox Object",\n    type: "*",\n  },\n\n  startLongitude: {\n    displayName: "Start Longitude",\n    type: "number",\n    group: "Coordinates",\n    default: 0,\n  },\n  startLatitute: {\n    displayName: "Start Latitude",\n    type: "number",\n    group: "Coordinates",\n    default: 0,\n  },\n\n  endLongitude: {\n    displayName: "End Longitude",\n    type: "number",\n    group: "Coordinates",\n    default: 0,\n  },\n  endLatitute: {\n    displayName: "End Latitude",\n    type: "number",\n    group: "Coordinates",\n    default: 0,\n  },\n\n  // You can read more about Routing profiles here:\n  // https://docs.mapbox.com/api/navigation/directions/#routing-profiles\n  routingProfile: {\n    displayName: "Routing Profile",\n    type: {\n      name: "enum",\n      enums: [\n        {\n          label: "Driving Traffic",\n          value: "mapbox/driving-traffic",\n        },\n        {\n          label: "Driving",\n          value: "mapbox/driving",\n        },\n        {\n          label: "Walking",\n          value: "mapbox/walking",\n        },\n        {\n          label: "Cycling",\n          value: "mapbox/cycling",\n        },\n      ],\n    },\n    default: "mapbox/cycling",\n  },\n};\n\nScript.Outputs = {\n  Steps: "array",\n  Duration: "number",\n};\n\nScript.Signals.CreateRoute = function () {\n  const map = Script.Inputs.Map;\n  const startCoords = [\n    Script.Inputs.startLongitude,\n    Script.Inputs.startLatitute,\n  ];\n  const endCoords = [Script.Inputs.endLongitude, Script.Inputs.endLatitute];\n\n  // Add starting point to the map\n  map.addLayer({\n    id: "point",\n    type: "circle",\n    source: {\n      type: "geojson",\n      data: {\n        type: "FeatureCollection",\n        features: [\n          {\n            type: "Feature",\n            properties: {},\n            geometry: {\n              type: "Point",\n              coordinates: startCoords,\n            },\n          },\n        ],\n      },\n    },\n    paint: {\n      "circle-radius": 10,\n      "circle-color": "#3887be",\n    },\n  });\n\n  const endPoint = {\n    type: "FeatureCollection",\n    features: [\n      {\n        type: "Feature",\n        properties: {},\n        geometry: {\n          type: "Point",\n          coordinates: endCoords,\n        },\n      },\n    ],\n  };\n\n  if (map.getLayer("end")) {\n    map.getSource("end").setData(endPoint);\n  } else {\n    map.addLayer({\n      id: "end",\n      type: "circle",\n      source: {\n        type: "geojson",\n        data: {\n          type: "FeatureCollection",\n          features: [\n            {\n              type: "Feature",\n              properties: {},\n              geometry: {\n                type: "Point",\n                coordinates: endCoords,\n              },\n            },\n          ],\n        },\n      },\n      paint: {\n        "circle-radius": 10,\n        "circle-color": "#f30",\n      },\n    });\n  }\n\n  // make an directions request that\n  getRoute(map, startCoords, endCoords).then((data) => {\n    // Extract the steps / instructions\n    const steps = data.legs[0].steps;\n    Script.Outputs.Steps = steps;\n\n    Script.Outputs.Duration = Math.floor(data.duration / 60);\n  });\n};\n')))}m.isMDXComponent=!0}}]);